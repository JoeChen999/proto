// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PBMsgHeader.proto

#ifndef PROTOBUF_PBMsgHeader_2eproto__INCLUDED
#define PROTOBUF_PBMsgHeader_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PBMsgHeader_2eproto();
void protobuf_AssignDesc_PBMsgHeader_2eproto();
void protobuf_ShutdownFile_PBMsgHeader_2eproto();

class PBMsgHeader;

// ===================================================================

class PBMsgHeader : public ::google::protobuf::Message {
 public:
  PBMsgHeader();
  virtual ~PBMsgHeader();

  PBMsgHeader(const PBMsgHeader& from);

  inline PBMsgHeader& operator=(const PBMsgHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PBMsgHeader& default_instance();

  void Swap(PBMsgHeader* other);

  // implements Message ----------------------------------------------

  PBMsgHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PBMsgHeader& from);
  void MergeFrom(const PBMsgHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string naId = 1;
  inline bool has_naid() const;
  inline void clear_naid();
  static const int kNaIdFieldNumber = 1;
  inline const ::std::string& naid() const;
  inline void set_naid(const ::std::string& value);
  inline void set_naid(const char* value);
  inline void set_naid(const char* value, size_t size);
  inline ::std::string* mutable_naid();
  inline ::std::string* release_naid();
  inline void set_allocated_naid(::std::string* naid);

  // required string gcUid = 2;
  inline bool has_gcuid() const;
  inline void clear_gcuid();
  static const int kGcUidFieldNumber = 2;
  inline const ::std::string& gcuid() const;
  inline void set_gcuid(const ::std::string& value);
  inline void set_gcuid(const char* value);
  inline void set_gcuid(const char* value, size_t size);
  inline ::std::string* mutable_gcuid();
  inline ::std::string* release_gcuid();
  inline void set_allocated_gcuid(::std::string* gcuid);

  // required string gcUnick = 3;
  inline bool has_gcunick() const;
  inline void clear_gcunick();
  static const int kGcUnickFieldNumber = 3;
  inline const ::std::string& gcunick() const;
  inline void set_gcunick(const ::std::string& value);
  inline void set_gcunick(const char* value);
  inline void set_gcunick(const char* value, size_t size);
  inline ::std::string* mutable_gcunick();
  inline ::std::string* release_gcunick();
  inline void set_allocated_gcunick(::std::string* gcunick);

  // required string mobileId = 4;
  inline bool has_mobileid() const;
  inline void clear_mobileid();
  static const int kMobileIdFieldNumber = 4;
  inline const ::std::string& mobileid() const;
  inline void set_mobileid(const ::std::string& value);
  inline void set_mobileid(const char* value);
  inline void set_mobileid(const char* value, size_t size);
  inline ::std::string* mutable_mobileid();
  inline ::std::string* release_mobileid();
  inline void set_allocated_mobileid(::std::string* mobileid);

  // required int32 platformId = 5;
  inline bool has_platformid() const;
  inline void clear_platformid();
  static const int kPlatformIdFieldNumber = 5;
  inline ::google::protobuf::int32 platformid() const;
  inline void set_platformid(::google::protobuf::int32 value);

  // required string becomeUserId = 6;
  inline bool has_becomeuserid() const;
  inline void clear_becomeuserid();
  static const int kBecomeUserIdFieldNumber = 6;
  inline const ::std::string& becomeuserid() const;
  inline void set_becomeuserid(const ::std::string& value);
  inline void set_becomeuserid(const char* value);
  inline void set_becomeuserid(const char* value, size_t size);
  inline ::std::string* mutable_becomeuserid();
  inline ::std::string* release_becomeuserid();
  inline void set_allocated_becomeuserid(::std::string* becomeuserid);

  // required string becomePassword = 7;
  inline bool has_becomepassword() const;
  inline void clear_becomepassword();
  static const int kBecomePasswordFieldNumber = 7;
  inline const ::std::string& becomepassword() const;
  inline void set_becomepassword(const ::std::string& value);
  inline void set_becomepassword(const char* value);
  inline void set_becomepassword(const char* value, size_t size);
  inline ::std::string* mutable_becomepassword();
  inline ::std::string* release_becomepassword();
  inline void set_allocated_becomepassword(::std::string* becomepassword);

  // required int32 debug = 8;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 8;
  inline ::google::protobuf::int32 debug() const;
  inline void set_debug(::google::protobuf::int32 value);

  // required string gVer = 9;
  inline bool has_gver() const;
  inline void clear_gver();
  static const int kGVerFieldNumber = 9;
  inline const ::std::string& gver() const;
  inline void set_gver(const ::std::string& value);
  inline void set_gver(const char* value);
  inline void set_gver(const char* value, size_t size);
  inline ::std::string* mutable_gver();
  inline ::std::string* release_gver();
  inline void set_allocated_gver(::std::string* gver);

  // required int64 gameSlot = 10;
  inline bool has_gameslot() const;
  inline void clear_gameslot();
  static const int kGameSlotFieldNumber = 10;
  inline ::google::protobuf::int64 gameslot() const;
  inline void set_gameslot(::google::protobuf::int64 value);

  // required int32 theme = 11;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 11;
  inline ::google::protobuf::int32 theme() const;
  inline void set_theme(::google::protobuf::int32 value);

  // required string newLang = 12;
  inline bool has_newlang() const;
  inline void clear_newlang();
  static const int kNewLangFieldNumber = 12;
  inline const ::std::string& newlang() const;
  inline void set_newlang(const ::std::string& value);
  inline void set_newlang(const char* value);
  inline void set_newlang(const char* value, size_t size);
  inline ::std::string* mutable_newlang();
  inline ::std::string* release_newlang();
  inline void set_allocated_newlang(::std::string* newlang);

  // required int64 gameNumber = 13;
  inline bool has_gamenumber() const;
  inline void clear_gamenumber();
  static const int kGameNumberFieldNumber = 13;
  inline ::google::protobuf::int64 gamenumber() const;
  inline void set_gamenumber(::google::protobuf::int64 value);

  // optional string kabamId = 14;
  inline bool has_kabamid() const;
  inline void clear_kabamid();
  static const int kKabamIdFieldNumber = 14;
  inline const ::std::string& kabamid() const;
  inline void set_kabamid(const ::std::string& value);
  inline void set_kabamid(const char* value);
  inline void set_kabamid(const char* value, size_t size);
  inline ::std::string* mutable_kabamid();
  inline ::std::string* release_kabamid();
  inline void set_allocated_kabamid(::std::string* kabamid);

  // optional string access_token = 15;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 15;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:PBMsgHeader)
 private:
  inline void set_has_naid();
  inline void clear_has_naid();
  inline void set_has_gcuid();
  inline void clear_has_gcuid();
  inline void set_has_gcunick();
  inline void clear_has_gcunick();
  inline void set_has_mobileid();
  inline void clear_has_mobileid();
  inline void set_has_platformid();
  inline void clear_has_platformid();
  inline void set_has_becomeuserid();
  inline void clear_has_becomeuserid();
  inline void set_has_becomepassword();
  inline void clear_has_becomepassword();
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_gver();
  inline void clear_has_gver();
  inline void set_has_gameslot();
  inline void clear_has_gameslot();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_newlang();
  inline void clear_has_newlang();
  inline void set_has_gamenumber();
  inline void clear_has_gamenumber();
  inline void set_has_kabamid();
  inline void clear_has_kabamid();
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* naid_;
  ::std::string* gcuid_;
  ::std::string* gcunick_;
  ::std::string* mobileid_;
  ::std::string* becomeuserid_;
  ::google::protobuf::int32 platformid_;
  ::google::protobuf::int32 debug_;
  ::std::string* becomepassword_;
  ::std::string* gver_;
  ::google::protobuf::int64 gameslot_;
  ::std::string* newlang_;
  ::google::protobuf::int64 gamenumber_;
  ::std::string* kabamid_;
  ::std::string* access_token_;
  ::google::protobuf::int32 theme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_PBMsgHeader_2eproto();
  friend void protobuf_AssignDesc_PBMsgHeader_2eproto();
  friend void protobuf_ShutdownFile_PBMsgHeader_2eproto();

  void InitAsDefaultInstance();
  static PBMsgHeader* default_instance_;
};
// ===================================================================


// ===================================================================

// PBMsgHeader

// required string naId = 1;
inline bool PBMsgHeader::has_naid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBMsgHeader::set_has_naid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBMsgHeader::clear_has_naid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBMsgHeader::clear_naid() {
  if (naid_ != &::google::protobuf::internal::kEmptyString) {
    naid_->clear();
  }
  clear_has_naid();
}
inline const ::std::string& PBMsgHeader::naid() const {
  return *naid_;
}
inline void PBMsgHeader::set_naid(const ::std::string& value) {
  set_has_naid();
  if (naid_ == &::google::protobuf::internal::kEmptyString) {
    naid_ = new ::std::string;
  }
  naid_->assign(value);
}
inline void PBMsgHeader::set_naid(const char* value) {
  set_has_naid();
  if (naid_ == &::google::protobuf::internal::kEmptyString) {
    naid_ = new ::std::string;
  }
  naid_->assign(value);
}
inline void PBMsgHeader::set_naid(const char* value, size_t size) {
  set_has_naid();
  if (naid_ == &::google::protobuf::internal::kEmptyString) {
    naid_ = new ::std::string;
  }
  naid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_naid() {
  set_has_naid();
  if (naid_ == &::google::protobuf::internal::kEmptyString) {
    naid_ = new ::std::string;
  }
  return naid_;
}
inline ::std::string* PBMsgHeader::release_naid() {
  clear_has_naid();
  if (naid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = naid_;
    naid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_naid(::std::string* naid) {
  if (naid_ != &::google::protobuf::internal::kEmptyString) {
    delete naid_;
  }
  if (naid) {
    set_has_naid();
    naid_ = naid;
  } else {
    clear_has_naid();
    naid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gcUid = 2;
inline bool PBMsgHeader::has_gcuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBMsgHeader::set_has_gcuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBMsgHeader::clear_has_gcuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBMsgHeader::clear_gcuid() {
  if (gcuid_ != &::google::protobuf::internal::kEmptyString) {
    gcuid_->clear();
  }
  clear_has_gcuid();
}
inline const ::std::string& PBMsgHeader::gcuid() const {
  return *gcuid_;
}
inline void PBMsgHeader::set_gcuid(const ::std::string& value) {
  set_has_gcuid();
  if (gcuid_ == &::google::protobuf::internal::kEmptyString) {
    gcuid_ = new ::std::string;
  }
  gcuid_->assign(value);
}
inline void PBMsgHeader::set_gcuid(const char* value) {
  set_has_gcuid();
  if (gcuid_ == &::google::protobuf::internal::kEmptyString) {
    gcuid_ = new ::std::string;
  }
  gcuid_->assign(value);
}
inline void PBMsgHeader::set_gcuid(const char* value, size_t size) {
  set_has_gcuid();
  if (gcuid_ == &::google::protobuf::internal::kEmptyString) {
    gcuid_ = new ::std::string;
  }
  gcuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_gcuid() {
  set_has_gcuid();
  if (gcuid_ == &::google::protobuf::internal::kEmptyString) {
    gcuid_ = new ::std::string;
  }
  return gcuid_;
}
inline ::std::string* PBMsgHeader::release_gcuid() {
  clear_has_gcuid();
  if (gcuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gcuid_;
    gcuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_gcuid(::std::string* gcuid) {
  if (gcuid_ != &::google::protobuf::internal::kEmptyString) {
    delete gcuid_;
  }
  if (gcuid) {
    set_has_gcuid();
    gcuid_ = gcuid;
  } else {
    clear_has_gcuid();
    gcuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gcUnick = 3;
inline bool PBMsgHeader::has_gcunick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PBMsgHeader::set_has_gcunick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PBMsgHeader::clear_has_gcunick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PBMsgHeader::clear_gcunick() {
  if (gcunick_ != &::google::protobuf::internal::kEmptyString) {
    gcunick_->clear();
  }
  clear_has_gcunick();
}
inline const ::std::string& PBMsgHeader::gcunick() const {
  return *gcunick_;
}
inline void PBMsgHeader::set_gcunick(const ::std::string& value) {
  set_has_gcunick();
  if (gcunick_ == &::google::protobuf::internal::kEmptyString) {
    gcunick_ = new ::std::string;
  }
  gcunick_->assign(value);
}
inline void PBMsgHeader::set_gcunick(const char* value) {
  set_has_gcunick();
  if (gcunick_ == &::google::protobuf::internal::kEmptyString) {
    gcunick_ = new ::std::string;
  }
  gcunick_->assign(value);
}
inline void PBMsgHeader::set_gcunick(const char* value, size_t size) {
  set_has_gcunick();
  if (gcunick_ == &::google::protobuf::internal::kEmptyString) {
    gcunick_ = new ::std::string;
  }
  gcunick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_gcunick() {
  set_has_gcunick();
  if (gcunick_ == &::google::protobuf::internal::kEmptyString) {
    gcunick_ = new ::std::string;
  }
  return gcunick_;
}
inline ::std::string* PBMsgHeader::release_gcunick() {
  clear_has_gcunick();
  if (gcunick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gcunick_;
    gcunick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_gcunick(::std::string* gcunick) {
  if (gcunick_ != &::google::protobuf::internal::kEmptyString) {
    delete gcunick_;
  }
  if (gcunick) {
    set_has_gcunick();
    gcunick_ = gcunick;
  } else {
    clear_has_gcunick();
    gcunick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string mobileId = 4;
inline bool PBMsgHeader::has_mobileid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PBMsgHeader::set_has_mobileid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PBMsgHeader::clear_has_mobileid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PBMsgHeader::clear_mobileid() {
  if (mobileid_ != &::google::protobuf::internal::kEmptyString) {
    mobileid_->clear();
  }
  clear_has_mobileid();
}
inline const ::std::string& PBMsgHeader::mobileid() const {
  return *mobileid_;
}
inline void PBMsgHeader::set_mobileid(const ::std::string& value) {
  set_has_mobileid();
  if (mobileid_ == &::google::protobuf::internal::kEmptyString) {
    mobileid_ = new ::std::string;
  }
  mobileid_->assign(value);
}
inline void PBMsgHeader::set_mobileid(const char* value) {
  set_has_mobileid();
  if (mobileid_ == &::google::protobuf::internal::kEmptyString) {
    mobileid_ = new ::std::string;
  }
  mobileid_->assign(value);
}
inline void PBMsgHeader::set_mobileid(const char* value, size_t size) {
  set_has_mobileid();
  if (mobileid_ == &::google::protobuf::internal::kEmptyString) {
    mobileid_ = new ::std::string;
  }
  mobileid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_mobileid() {
  set_has_mobileid();
  if (mobileid_ == &::google::protobuf::internal::kEmptyString) {
    mobileid_ = new ::std::string;
  }
  return mobileid_;
}
inline ::std::string* PBMsgHeader::release_mobileid() {
  clear_has_mobileid();
  if (mobileid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobileid_;
    mobileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_mobileid(::std::string* mobileid) {
  if (mobileid_ != &::google::protobuf::internal::kEmptyString) {
    delete mobileid_;
  }
  if (mobileid) {
    set_has_mobileid();
    mobileid_ = mobileid;
  } else {
    clear_has_mobileid();
    mobileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 platformId = 5;
inline bool PBMsgHeader::has_platformid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PBMsgHeader::set_has_platformid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PBMsgHeader::clear_has_platformid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PBMsgHeader::clear_platformid() {
  platformid_ = 0;
  clear_has_platformid();
}
inline ::google::protobuf::int32 PBMsgHeader::platformid() const {
  return platformid_;
}
inline void PBMsgHeader::set_platformid(::google::protobuf::int32 value) {
  set_has_platformid();
  platformid_ = value;
}

// required string becomeUserId = 6;
inline bool PBMsgHeader::has_becomeuserid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PBMsgHeader::set_has_becomeuserid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PBMsgHeader::clear_has_becomeuserid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PBMsgHeader::clear_becomeuserid() {
  if (becomeuserid_ != &::google::protobuf::internal::kEmptyString) {
    becomeuserid_->clear();
  }
  clear_has_becomeuserid();
}
inline const ::std::string& PBMsgHeader::becomeuserid() const {
  return *becomeuserid_;
}
inline void PBMsgHeader::set_becomeuserid(const ::std::string& value) {
  set_has_becomeuserid();
  if (becomeuserid_ == &::google::protobuf::internal::kEmptyString) {
    becomeuserid_ = new ::std::string;
  }
  becomeuserid_->assign(value);
}
inline void PBMsgHeader::set_becomeuserid(const char* value) {
  set_has_becomeuserid();
  if (becomeuserid_ == &::google::protobuf::internal::kEmptyString) {
    becomeuserid_ = new ::std::string;
  }
  becomeuserid_->assign(value);
}
inline void PBMsgHeader::set_becomeuserid(const char* value, size_t size) {
  set_has_becomeuserid();
  if (becomeuserid_ == &::google::protobuf::internal::kEmptyString) {
    becomeuserid_ = new ::std::string;
  }
  becomeuserid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_becomeuserid() {
  set_has_becomeuserid();
  if (becomeuserid_ == &::google::protobuf::internal::kEmptyString) {
    becomeuserid_ = new ::std::string;
  }
  return becomeuserid_;
}
inline ::std::string* PBMsgHeader::release_becomeuserid() {
  clear_has_becomeuserid();
  if (becomeuserid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = becomeuserid_;
    becomeuserid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_becomeuserid(::std::string* becomeuserid) {
  if (becomeuserid_ != &::google::protobuf::internal::kEmptyString) {
    delete becomeuserid_;
  }
  if (becomeuserid) {
    set_has_becomeuserid();
    becomeuserid_ = becomeuserid;
  } else {
    clear_has_becomeuserid();
    becomeuserid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string becomePassword = 7;
inline bool PBMsgHeader::has_becomepassword() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PBMsgHeader::set_has_becomepassword() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PBMsgHeader::clear_has_becomepassword() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PBMsgHeader::clear_becomepassword() {
  if (becomepassword_ != &::google::protobuf::internal::kEmptyString) {
    becomepassword_->clear();
  }
  clear_has_becomepassword();
}
inline const ::std::string& PBMsgHeader::becomepassword() const {
  return *becomepassword_;
}
inline void PBMsgHeader::set_becomepassword(const ::std::string& value) {
  set_has_becomepassword();
  if (becomepassword_ == &::google::protobuf::internal::kEmptyString) {
    becomepassword_ = new ::std::string;
  }
  becomepassword_->assign(value);
}
inline void PBMsgHeader::set_becomepassword(const char* value) {
  set_has_becomepassword();
  if (becomepassword_ == &::google::protobuf::internal::kEmptyString) {
    becomepassword_ = new ::std::string;
  }
  becomepassword_->assign(value);
}
inline void PBMsgHeader::set_becomepassword(const char* value, size_t size) {
  set_has_becomepassword();
  if (becomepassword_ == &::google::protobuf::internal::kEmptyString) {
    becomepassword_ = new ::std::string;
  }
  becomepassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_becomepassword() {
  set_has_becomepassword();
  if (becomepassword_ == &::google::protobuf::internal::kEmptyString) {
    becomepassword_ = new ::std::string;
  }
  return becomepassword_;
}
inline ::std::string* PBMsgHeader::release_becomepassword() {
  clear_has_becomepassword();
  if (becomepassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = becomepassword_;
    becomepassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_becomepassword(::std::string* becomepassword) {
  if (becomepassword_ != &::google::protobuf::internal::kEmptyString) {
    delete becomepassword_;
  }
  if (becomepassword) {
    set_has_becomepassword();
    becomepassword_ = becomepassword;
  } else {
    clear_has_becomepassword();
    becomepassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 debug = 8;
inline bool PBMsgHeader::has_debug() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PBMsgHeader::set_has_debug() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PBMsgHeader::clear_has_debug() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PBMsgHeader::clear_debug() {
  debug_ = 0;
  clear_has_debug();
}
inline ::google::protobuf::int32 PBMsgHeader::debug() const {
  return debug_;
}
inline void PBMsgHeader::set_debug(::google::protobuf::int32 value) {
  set_has_debug();
  debug_ = value;
}

// required string gVer = 9;
inline bool PBMsgHeader::has_gver() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PBMsgHeader::set_has_gver() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PBMsgHeader::clear_has_gver() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PBMsgHeader::clear_gver() {
  if (gver_ != &::google::protobuf::internal::kEmptyString) {
    gver_->clear();
  }
  clear_has_gver();
}
inline const ::std::string& PBMsgHeader::gver() const {
  return *gver_;
}
inline void PBMsgHeader::set_gver(const ::std::string& value) {
  set_has_gver();
  if (gver_ == &::google::protobuf::internal::kEmptyString) {
    gver_ = new ::std::string;
  }
  gver_->assign(value);
}
inline void PBMsgHeader::set_gver(const char* value) {
  set_has_gver();
  if (gver_ == &::google::protobuf::internal::kEmptyString) {
    gver_ = new ::std::string;
  }
  gver_->assign(value);
}
inline void PBMsgHeader::set_gver(const char* value, size_t size) {
  set_has_gver();
  if (gver_ == &::google::protobuf::internal::kEmptyString) {
    gver_ = new ::std::string;
  }
  gver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_gver() {
  set_has_gver();
  if (gver_ == &::google::protobuf::internal::kEmptyString) {
    gver_ = new ::std::string;
  }
  return gver_;
}
inline ::std::string* PBMsgHeader::release_gver() {
  clear_has_gver();
  if (gver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gver_;
    gver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_gver(::std::string* gver) {
  if (gver_ != &::google::protobuf::internal::kEmptyString) {
    delete gver_;
  }
  if (gver) {
    set_has_gver();
    gver_ = gver;
  } else {
    clear_has_gver();
    gver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 gameSlot = 10;
inline bool PBMsgHeader::has_gameslot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PBMsgHeader::set_has_gameslot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PBMsgHeader::clear_has_gameslot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PBMsgHeader::clear_gameslot() {
  gameslot_ = GOOGLE_LONGLONG(0);
  clear_has_gameslot();
}
inline ::google::protobuf::int64 PBMsgHeader::gameslot() const {
  return gameslot_;
}
inline void PBMsgHeader::set_gameslot(::google::protobuf::int64 value) {
  set_has_gameslot();
  gameslot_ = value;
}

// required int32 theme = 11;
inline bool PBMsgHeader::has_theme() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PBMsgHeader::set_has_theme() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PBMsgHeader::clear_has_theme() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PBMsgHeader::clear_theme() {
  theme_ = 0;
  clear_has_theme();
}
inline ::google::protobuf::int32 PBMsgHeader::theme() const {
  return theme_;
}
inline void PBMsgHeader::set_theme(::google::protobuf::int32 value) {
  set_has_theme();
  theme_ = value;
}

// required string newLang = 12;
inline bool PBMsgHeader::has_newlang() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PBMsgHeader::set_has_newlang() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PBMsgHeader::clear_has_newlang() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PBMsgHeader::clear_newlang() {
  if (newlang_ != &::google::protobuf::internal::kEmptyString) {
    newlang_->clear();
  }
  clear_has_newlang();
}
inline const ::std::string& PBMsgHeader::newlang() const {
  return *newlang_;
}
inline void PBMsgHeader::set_newlang(const ::std::string& value) {
  set_has_newlang();
  if (newlang_ == &::google::protobuf::internal::kEmptyString) {
    newlang_ = new ::std::string;
  }
  newlang_->assign(value);
}
inline void PBMsgHeader::set_newlang(const char* value) {
  set_has_newlang();
  if (newlang_ == &::google::protobuf::internal::kEmptyString) {
    newlang_ = new ::std::string;
  }
  newlang_->assign(value);
}
inline void PBMsgHeader::set_newlang(const char* value, size_t size) {
  set_has_newlang();
  if (newlang_ == &::google::protobuf::internal::kEmptyString) {
    newlang_ = new ::std::string;
  }
  newlang_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_newlang() {
  set_has_newlang();
  if (newlang_ == &::google::protobuf::internal::kEmptyString) {
    newlang_ = new ::std::string;
  }
  return newlang_;
}
inline ::std::string* PBMsgHeader::release_newlang() {
  clear_has_newlang();
  if (newlang_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newlang_;
    newlang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_newlang(::std::string* newlang) {
  if (newlang_ != &::google::protobuf::internal::kEmptyString) {
    delete newlang_;
  }
  if (newlang) {
    set_has_newlang();
    newlang_ = newlang;
  } else {
    clear_has_newlang();
    newlang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 gameNumber = 13;
inline bool PBMsgHeader::has_gamenumber() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PBMsgHeader::set_has_gamenumber() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PBMsgHeader::clear_has_gamenumber() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PBMsgHeader::clear_gamenumber() {
  gamenumber_ = GOOGLE_LONGLONG(0);
  clear_has_gamenumber();
}
inline ::google::protobuf::int64 PBMsgHeader::gamenumber() const {
  return gamenumber_;
}
inline void PBMsgHeader::set_gamenumber(::google::protobuf::int64 value) {
  set_has_gamenumber();
  gamenumber_ = value;
}

// optional string kabamId = 14;
inline bool PBMsgHeader::has_kabamid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PBMsgHeader::set_has_kabamid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PBMsgHeader::clear_has_kabamid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PBMsgHeader::clear_kabamid() {
  if (kabamid_ != &::google::protobuf::internal::kEmptyString) {
    kabamid_->clear();
  }
  clear_has_kabamid();
}
inline const ::std::string& PBMsgHeader::kabamid() const {
  return *kabamid_;
}
inline void PBMsgHeader::set_kabamid(const ::std::string& value) {
  set_has_kabamid();
  if (kabamid_ == &::google::protobuf::internal::kEmptyString) {
    kabamid_ = new ::std::string;
  }
  kabamid_->assign(value);
}
inline void PBMsgHeader::set_kabamid(const char* value) {
  set_has_kabamid();
  if (kabamid_ == &::google::protobuf::internal::kEmptyString) {
    kabamid_ = new ::std::string;
  }
  kabamid_->assign(value);
}
inline void PBMsgHeader::set_kabamid(const char* value, size_t size) {
  set_has_kabamid();
  if (kabamid_ == &::google::protobuf::internal::kEmptyString) {
    kabamid_ = new ::std::string;
  }
  kabamid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_kabamid() {
  set_has_kabamid();
  if (kabamid_ == &::google::protobuf::internal::kEmptyString) {
    kabamid_ = new ::std::string;
  }
  return kabamid_;
}
inline ::std::string* PBMsgHeader::release_kabamid() {
  clear_has_kabamid();
  if (kabamid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kabamid_;
    kabamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_kabamid(::std::string* kabamid) {
  if (kabamid_ != &::google::protobuf::internal::kEmptyString) {
    delete kabamid_;
  }
  if (kabamid) {
    set_has_kabamid();
    kabamid_ = kabamid;
  } else {
    clear_has_kabamid();
    kabamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string access_token = 15;
inline bool PBMsgHeader::has_access_token() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PBMsgHeader::set_has_access_token() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PBMsgHeader::clear_has_access_token() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PBMsgHeader::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& PBMsgHeader::access_token() const {
  return *access_token_;
}
inline void PBMsgHeader::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void PBMsgHeader::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void PBMsgHeader::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBMsgHeader::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* PBMsgHeader::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBMsgHeader::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PBMsgHeader_2eproto__INCLUDED
